# Sunny Game Engine C++ 스타일 가이드

기본적으로 [구글 C++ 스타일 가이드](http://jongwook.kim/google-styleguide/trunk/cppguide.xml)를 따르며, 약간의 수정사항이 존재한다.


## 배경

C++은 KPU 졸업 작품 프로젝트에서 사용하는 주요한 개발 언어이다. C++ 언어는 강력한 기능을 많이 가지고 있으나, 그 강력함은 복잡함을 야기하고 그로 인해 버그가 생기기 쉬운 코드가 되거나 읽고 관리하기 어려운 코드가 될 수 있다.

이 가이드의 목표는 Sunny Engine을 개발하는데 있어 해야 할 것과 하지 말아야할 것을 자세하게 서술해서 복잡함을 관리하는 것이다. 이러한 규칙들은 C++ 언어의 기능들을 계속하여 생산적으로 사용하면서도 기반코드를 관리가능한 상태로 유지하기 위한 것이다.

* *가독성*이라고도 부르는 이 *스타일*은,  C++로 개발된 Sunny Engine 코드를 지배하는 컨벤션이다.

Sunny Engine의 기반 코드를 관리할 수 있게 유지하는 한 가지 방법은 *일관성*을 강제하는 것이다. 어떤 프로그래머라도 남의 코드를 볼 수 있고 쉽게 이해할 수 잇는 것은 매우 중요하다. 일치된 스타일을 유지하고 컨벤션에 따른다는 것은 더 쉽게 "패턴 매칭"을 사용하여 다양한 기호들이 무엇을 의미하고 어떤 값이 변함없이 참인지를 추측할 수 있다는 것을 의미한다. 모두가 필수적으로 사용할 숙어와 패턴을 만들면 코드를 이해하는 것이 훨씬 쉬어진다.

Sunny Engine 프로젝트는 이 가이드의 요구사항을 따른다.


## 헤더파일

**기본적으로 모든 .cpp파일은 .h 파일을 가져야한다.**

예외로는 main() 함수만을 가진 작은 .cpp 파일이 있다.

### #progma once 가드

**모든 헤더 파일은 여러 번 포함 되지 않기 위해 #progma once 가드를 사용해야 한다.**

### 인라인 함수

**일반적으로 getter/setter는 인라인 함수로 작성한다.**

**오와 열을 맞춘다.**

### 함수 인자 순서

**함수를 정의할 때 인자 순서는 입력이 먼저이고 출력이 다음이다.**

C++ 함수의 인자는 입력이거나 출력이거나 둘 다 일수 있다. 입력 인자는 보통 값(value)이거나 const 레퍼런스이고, 출력과 입출력 인자는 const가 아닌 포인터가 될 것이다. 함수 인자를 순서에 따라 배열할 때, 모든 입력 전용 인자를 출력 인자보다 앞에 두자. 특히 단순히 새롭다는 이유로 새 인자를 함수 마지막에 추가하지 말자.

### #include의 이름과 순서

**가독성을 높이고 숨겨진 종속성을 피하기 위해서 다음과 같은 순서를 사용한다.**

- C 라이브러리
- C++ 라이브러리
- 다른 라이브러리들의 .h
- Sunny Engine 프로젝트의 .h

**모든 헤더 파일은 .이나 ..을 이용한 상대 경로를 사용하지 않고 절대 경로를 사용한다.**

## 범위

### 네임스페이스

**Sunny Engine의 모든 파일은 sunny 네임스페이스에서 시작해 주로 폴더 단위의 경로에 기반한 이름을 사용한다.**

- using 지시자를 사용하지 않는다.
- 인라인 네임스페이스를 사용하지 않는다.

네임스페이스는 #include 구문 아래아래 에서부터 전체 소스 파일을 감싼다.

### 지역 변수

**함수의 변수는 가능한 좁은 범위에 두고, 선언에서 초기화한다.**

C++에서는 함수 어느 곳에서나 변수 선언을 할 수 있지만, 변수를 가능한 한 좁은 범위로 선언하고 최대한 첫 번째 사용처에 가깝게 선언한다.

```cpp
/*
선언과 대입 대신 초기화를 사용한다.
읽는 사람이 선언을 찾고 변수의 타입과 초기값을 알아내는 것을 쉽게 한다.
*/

// 나쁨: 선언과 초기화가 분리되어 있다.
int i;
i = f();

// 좋음: 선언이 초기화를 가지고 있다.
int i = f();

// 나쁨: 중괄호 초기화를 사용하여 초기화하는
vector<int> v;
v.push_back(1);
v.push_back(2);

// 좋음: v는 시작부터 초기화 된다.
vector<int> v = { 1, 2 };
```

**경고한다. 만약 변수가 객체이면 그 생성자는 반복문 범위에 들어가서 생성되는 때마다 호출되고 그 소멸자는 범위를 빠져나갈 때마다 호출된다.**

```cpp
// 비효율적인 구현
for(int i = 0; i < 1000000; ++i)
{
	Some a;    // 생성자와 소멸자는 각각 1000000회 호출된다.
	a.doSomething(i);
}

// 반복문에서 사용되는 이런 변수를 선언할 때는 반복문 바깥에 하는 것이 성능에 좋을 수 있다.
Some a;
for(int i = 0; i < 1000000; ++i)
{
	a.doSomething(i);
}
```

## 클래스

클래스는 C++ 코드에서 널리 사용하는 기본적이 단위다.

### 구조체 vs 클래스

**데이터를 나르는 수동적인 객체의 경우는 struct을 사용한다. 그 외의 모든 경우에는 class를 싸용한다.**

C++ 언어에서 stuct와 class 키워드는 거의 똑같이 동작한다.(접근지시자 차이)

Sunny Engine에서는 각각의 키워드에 고유한 의미를 부여한다.

struct는 데이터를 나르는 수동적 객체로서 사용되고 연관된 상수들을 포함할 수 있으나, 어떠한 기능도 가져서는 안된다. 필드의 접근/변경은 메서드 호출이 아닌 직접 필드에 접근하는 방식으로 이루어진다.

만약 더 많은 기능이 필요하다면 class를 사용한다.

### 선언 순서

클래스 정의는 반드시 public: 부분으로 시작해야 하며, 그 다음에 protected: 부분이 따라오고 그 다음이 private: 부분이다. 만약 이 부분 중 비어 있는 것이 있다면, 그 부분을 생략한다.

각각의 부분 안에서 선언은 보통 아래와 같은 순서여야 한다.

- typedef들과 열거형
- 상수 (static const 데이터 멤버)
- 생성자
- 소멸자
- 데이터 멤버
- 정적 메서드를 포함한 모든 메서드

해당하는 .cpp 파일의 메서드 정의는 반드시 선언과 같은 순서여야 한다.


## 그 외

### 레퍼런스 인자

**레퍼런스로 전달되는 모든 인자는 const로 수식되어야 한다.**

함수가 변수를 변경할 필요가 있는 경우 인자는 포인터를 사용해야 한다.

### 형 변환

**static_cast<> 같은 C++ 형 변환을 사용한다.**

int y = (int)x 같은 C-Style 형 변환 형식을 사용하지 않는다.

### 전위 증가/ 감소

**이터레이터 및 반복문에서 증가와 감소 연산자에 접두어 형태 (++i)를 사용한다.**

### TODO 주석

**아직 완벽하지 않은 코드 혹은 임시적이고 단기적인 해결책에 TODO 주석을 사용한다.**

## 이름 규칙

일관성을 위한 가장 중요한 규칙은 이름 규칙을 통제하는 것이다.

### 일반 이름 규칙

**함수 이름, 변수 이름, 파일 이름은 약어를 피하고 서술적으로 지어야 한다.**

가능한 한 상세한 이름을 사용한다. 읽는 사람이 즉시 이해할 수 있는 것이 글자 길이를 줄이는 것보다 훨씬 중요하다.

- 약어를 사용하지 않는다.
- 중간 글자를 지워서 축약하지 않는다.

### 파일 이름

**파일 이름은 모두 소문자이어야 하고 띄어쓰기 대신 언더스코어를 사용한다.**

### 타입 이름

**타입 이름은 대문자로 시작하며, 언더스코어 없이 단어마다 첫 글자로 대문자를 사용한다.**

### 네임스페이스 이름

**네임스페이스 이름은 모두 소문자로 하며, 프로젝트 이름과 디렉토리 구조에 기반하여 작성한다.**

### 함수 이름

**메서드 이름은 모두 소문자로 하며, 첫 단어를 제외한 단어마다 첫 글자로 대문자를 사용한다.**

### 변수 이름

**변수 이름은 모두 소문자로 하며 단어 사이에 언더 스코어를 사용한다.**

### 열거형 이름

**열거형은 모두 대문자로 하며 단어 사이에 언더 스코어를 사용한다.**

### 상수 이름

**상수 이름은 k로 시작하는 대소문자가 섞인 이름을 사용한다. (k + 타입 이름)**
